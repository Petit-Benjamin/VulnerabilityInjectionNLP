import os
import shutil
import re
import insert_test_that_raise_the_vuln


def main_juliet_test_suite():
    # Main parameters
    """
    n_beam = 5
    test_set_log_path = "C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_diff6\\data\\test_logs.txt"
    # test_set_pred_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_diff6\\results\\pred-test_beam5_iter1000.txt'
    # test_set_pred_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_diff6\\results\\pred-test_beam5_iter3000_2.txt'
    test_set_pred_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_diff6\\results\\pred-test_beam5_iter10000.txt'
    test_set_bads_path = "C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_diff6\\data\\test_bads.txt"
    dataset_path = "C:\\Users\\benjamin.petit\\Documents\\Juliet_Test_Suite_v1.3_for_Java\\Java\\src\\testcases"
    dest_folder_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_diff6\\results\\prediction_java_files\\src\\testcases'
    """
    """
    n_beam = 5
    dataset_path = "C:\\Users\\benjamin.petit\\Documents\\\Juliet_Test_Suite_5CWE_req_only_OBFUSCATED"
    test_set_log_path = "C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_Obfuscated_B2Gonly_token_less_400\\data\\test_logs.txt"
    test_set_pred_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_Obfuscated_B2Gonly_token_less_400\\results\\test_good_beam5_iter30000.txt'
    test_set_bads_path = "C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_Obfuscated_B2Gonly_token_less_400\\data\\test_bads.txt"
    dest_folder_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_Obfuscated_B2Gonly_token_less_400\\results\\prediction_java_files\\src\\testcases'
    """

    n_beam = 5
    dataset_path = "C:\\Users\\benjamin.petit\\Documents\\Juliet_Test_Suite_5CWE_req_only_InferOK_OBFUSCATED"
    test_set_log_path = "C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_InferOK_token_less_150_Obfuscated\\fold0\\data\\test_logs.txt"
    test_set_pred_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_InferOK_token_less_150_Obfuscated\\fold0\\results\\test_beam5_iter10000.txt'
    test_set_bads_path = "C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_InferOK_token_less_150_Obfuscated\\fold0\\data\\test_bads.txt"
    dest_folder_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_InferOK_token_less_150_Obfuscated\\fold0\\results\\test_beam5_iter10000'

    try:
        os.mkdir(f'{dest_folder_path}')
    except:
        pass

    log_test_set_files = []
    with open(test_set_log_path, 'r') as log_test_set_file:
        for line in log_test_set_file:
            log_test_set_files.append(line[:-1])

    pred_patchs = []
    with open(test_set_pred_path, 'r') as pred_file:
        for i, line in enumerate(pred_file):
            if i % n_beam == 0:
                pred_patchs.append(line)

    test_set_bads = []
    with open(test_set_bads_path, 'r') as test_set_bads_file:
        for line in test_set_bads_file:
            test_set_bads.append(line[:-1])

    # Find all the initial files and copy them to the dest folder
    # Attention ! It is possible to need to copy more than one time a java file ! (If more than 1 good method come from this one)
    print("# Finding all the initials files and copy #")
    os.chdir(dataset_path)
    temp = log_test_set_files.copy()
    for root, dirs, files in os.walk("."):
        for file in files:
            if file in temp:
                i_file = 1  # It is possible to have more than 1 time each file (because X goods come from 1 file)
                while file is file in temp:
                    temp.remove(file)
                    shutil.copyfile(os.path.join(root, file), f"{dest_folder_path}\\{file[:-5]}_{i_file}.java")
                    i_file = i_file + 1

    if (len(log_test_set_files) == len(pred_patchs)):
        print(f"OK : Pred patch file and log test file contain the same number of lines ({len(pred_patchs)})")
    else:
        print("WARNING : Pred patch file and log test file don't contain the same number of lines !")
        print(f"prediction file : {len(pred_patchs)}")
        print(f"log file : {len(log_test_set_files)}")

    # For every file in the log test file, open it and insert the vulnerability
    # NB : Need to check each occurence of the file it is ! (x1.java , x2.java,...)
    # occur_file_list is there to know which file's occurence to use
    print("# Opening all files and replacement of the bad method #")
    occur_file_list = {file: 1 for file in set(log_test_set_files)}
    os.chdir(dest_folder_path)
    for i, file_to_modify in enumerate(log_test_set_files):
        file_to_modify_name = f"{file_to_modify[:-5]}_{occur_file_list[file_to_modify]}.java"

        # Does the prediction is exactly the same as the real ?
        identical_matching = False
        if (test_set_bads[i] == pred_patchs[i][:-1]):  # There is a space at the end of the pred_patch
            identical_matching = True

        with open(file_to_modify_name, 'r') as file:
            content1 = []
            content2 = []
            beginning_of_file = True
            count_brackets = 0
            start_bad_method = False
            for line in file:
                if line.startswith("package"):
                    content1.append("package testcases;\n")
                    content1.append("import java.security.SecureRandom;\n")
                    content1.append("import java.math.BigInteger;\n")  # Useful if we are on CWE190 or CWE191
                elif line.startswith("public class CWE"):
                    if "Servlet" in file_to_modify[:-5]:
                        content1.append(f"public class {file_to_modify[:-5]}_{occur_file_list[file_to_modify]}" + " extends AbstractTestCaseServlet { \n")
                    else:
                        content1.append(f"public class {file_to_modify[:-5]}_{occur_file_list[file_to_modify]}" + " extends AbstractTestCase { \n")
                else:
                    if re.search('void bad\(', line):
                        start_bad_method = True
                        beginning_of_file = False
                        count_brackets = 0

                    if start_bad_method == False:
                        if beginning_of_file == True:
                            content1.append(line)
                        else:
                            content2.append(line)

                    if re.search("{", line):
                        count_brackets = count_brackets + 1
                    if re.search("}", line):
                        count_brackets = count_brackets - 1
                        if (count_brackets == 0 and start_bad_method == True):
                            start_bad_method = False
                            # print("fin de la méthode")
        occur_file_list[file_to_modify] = occur_file_list[file_to_modify] + 1

        with open(file_to_modify_name, 'w') as file:
            patch = re.split(' \. ', pred_patchs[i])
            patch = '.'.join(patch)
            patch = re.split(' \+ ', patch)
            patch = '+'.join(patch)
            patch = re.split('> =', patch)
            patch = '>='.join(patch)
            patch = re.split('< =', patch)
            patch = '<='.join(patch)
            patch = re.split('- -', patch)
            patch = '--'.join(patch)
            patch = re.split('\+ \+', patch)
            patch = '++'.join(patch)

            towrite = "".join(content1)
            if identical_matching:
                towrite += "// IDENTICAL MATCHING WITH REAL BAD METHOD\n"

            """
            if file_to_modify_name.startswith("CWE190"):
                towrite += insert_test_that_raise_the_vuln.CWE190(patch)
            elif file_to_modify_name.startswith("CWE191"):
                towrite += insert_test_that_raise_the_vuln.CWE191(patch)
            else:
            """
            towrite += patch
            towrite += "".join(content2)
            file.write(towrite)


def main_my_java_project():
    # Main parameters
    n_beam = 5
    dataset_path = "C:\\Users\\benjamin.petit\\Documents\\my_java_project\\src"
    test_set_log_path = "C:\\Users\\benjamin.petit\\Documents\\my_java_project\\to_predict\\3_java_files_tokenized\\log_java_pred.txt"
    """
    test_set_pred_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_B2Gonly_diff10\\results\\java_pred_beam5_iter10000.txt'
    dest_folder_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_B2Gonly_diff10\\results\\prediction_java_files\\src'
    """
    test_set_pred_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_Obfuscated_B2Gonly_diff10_new\\results\\java_pred_beam5_iter20000_valtestjava.txt'
    dest_folder_path = 'C:\\Users\\benjamin.petit\\Documents\\Seq2seq\\OpenNMT_5CWE_Obfuscated_B2Gonly_diff10_new\\results\\prediction_java_files\\src'
    try:
        os.mkdir(f'{dest_folder_path}')
    except:
        pass

    log_test_set_files = []
    with open(test_set_log_path, 'r') as log_test_set_file:
        for line in log_test_set_file:
            log_test_set_files.append(line[:-1])

    pred_patchs = []
    with open(test_set_pred_path, 'r') as pred_file:
        for i, line in enumerate(pred_file):
            if i % n_beam == 0:
                pred_patchs.append(line)

    # Find all the initial files and copy them to the dest folder
    # Here I just need to copy one time because on good method will have one predicted bad method
    print("# Finding all the initials files and copy #")
    os.chdir(dataset_path)
    temp = [(file.split("___")[0],file.split("___")[1]) for file in log_test_set_files.copy()]
    print(temp)
    # e.g: CWE190_Main.java___cwe190_method_a().txt
    for root, dirs, files in os.walk("."):
        for file in files:
            print("CURRENT FILE IN DATASET " + file)
            for filename,methodname in temp:
                print(filename)
                if filename in file:
                    print(filename,methodname)
                    shutil.copyfile(os.path.join(root, file), os.path.join(dest_folder_path, file[:-5] +"___"+methodname[:-4] + ".java"))

    if (len(log_test_set_files) == len(pred_patchs)):
        print(f"OK : Pred patch file and log test file contain the same number of lines ({len(pred_patchs)})")
    else:
        print("WARNING : Pred patch file and log test file don't contain the same number of lines !")
        print(f"prediction file : {len(pred_patchs)}")
        print(f"log file : {len(log_test_set_files)}")

    # For every file in the log test file, open it and insert the vulnerability

    print("# Opening all files and replacement of the bad method #")
    os.chdir(dest_folder_path)
    for i, file_to_modify in enumerate(log_test_set_files):
        file_to_modify_name = file_to_modify.split("___")[0][:-5] + "___" +file_to_modify.split("___")[1][:-4] + ".java"
        method_to_modify_name = file_to_modify.split("___")[1][:-4] # remove .txt
        with open(file_to_modify_name, 'r') as file:
            content1 = []
            content2 = []
            beginning_of_file = True
            count_brackets = 0
            start_bad_method = False
            for line in file:
                if re.search(f'public static void {method_to_modify_name}\(', line):
                    print(method_to_modify_name + " detected")
                    start_bad_method = True
                    beginning_of_file = False
                    count_brackets = 0
                elif line.startswith("public class CWE"):
                    content1.append("public class " + file_to_modify_name[:-5] + "{ \n")

                elif start_bad_method == False:
                    if beginning_of_file == True:
                        content1.append(line)
                    else:
                        content2.append(line)

                if re.search("{", line):
                    count_brackets = count_brackets + 1
                if re.search("}", line):
                    count_brackets = count_brackets - 1
                    if (count_brackets == 0 and start_bad_method == True):
                        start_bad_method = False
                        # print("fin de la méthode")

        with open(file_to_modify_name, 'w') as file:
            patch = re.split(' \. ', pred_patchs[i])
            patch = '.'.join(patch)
            patch = re.split(' \+ ', patch)
            patch = '+'.join(patch)
            patch = re.split('> =', patch)
            patch = '>='.join(patch)
            patch = re.split('< =', patch)
            patch = '<='.join(patch)
            patch = re.split('- -', patch)
            patch = '--'.join(patch)
            patch = re.split('\+ \+', patch)
            patch = '++'.join(patch)

            # As the prediction predit a method named "bad", I must change its names
            patch = f"public static void {method_to_modify_name}" + patch[16:]

            towrite = "".join(content1)
            towrite += patch
            towrite += "".join(content2)
            file.write(towrite)

if __name__ == "__main__":
    main_juliet_test_suite()
    #main_my_java_project()
